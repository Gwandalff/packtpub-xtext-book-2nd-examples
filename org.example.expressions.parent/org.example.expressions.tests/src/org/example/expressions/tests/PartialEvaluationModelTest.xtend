/*
 * generated by Xtext 2.10.0
 */
package org.example.expressions.tests

import com.google.inject.Inject
import expressions.ExpressionsModel
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.example.expressions.interpreter.ExpressionsInterpreter
import org.example.expressions.interpreter.PartialEvaluator
import org.junit.Test
import org.junit.runner.RunWith

import static extension org.junit.Assert.*
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.util.EcoreUtil.EqualityHelper

@RunWith(XtextRunner)
@InjectWith(ExpressionsInjectorProvider)
class PartialEvaluationModelTest {

	@Inject extension ParseHelper<ExpressionsModel>
	@Inject extension ValidationTestHelper
	@Inject extension PartialEvaluator
	@Inject EqualityHelper eq

	@Test def void intConstant() { "eval 1".assertPartialEvaluated(1) }

	@Test def void boolConstant() { "eval true".assertPartialEvaluated(true) }

	@Test def void stringConstant() { "eval 'abc'".assertPartialEvaluated("abc") }

	@Test def void multi() { "eval 5 * 3".assertPartialEvaluated(15) }

	@Test def void div() { "eval 6 / 3".assertPartialEvaluated(2) }

	@Test def void minus() { "eval 6 - 2".assertPartialEvaluated(4) }

	@Test def void intPlus() { "eval 6 + 2".assertPartialEvaluated(8) }

	@Test def void stringPlus() { "eval 'a' + 'b'".assertPartialEvaluated('ab') }

	@Test def void intStringPlus() { "eval 'a' + 1".assertPartialEvaluated('a1') }

	@Test def void boolStringPlus() { "eval 'a' + true".assertPartialEvaluated('atrue') }

	@Test def void lessThanInt() { "eval 1 < 2".assertPartialEvaluated(true) }

	@Test def void lessEqualsThanInt() { "eval 2 <= 2".assertPartialEvaluated(true) }

	@Test def void greaterThanInt() { "eval 1 > 2".assertPartialEvaluated(false) }

	@Test def void greaterEqualsThanInt() { "eval 2 >= 1".assertPartialEvaluated(true) }

	@Test def void lessThanString() { "eval 'a' < 'b'".assertPartialEvaluated(true) }

	@Test def void lessEqualsThanString() { "eval 'a' <= 'ab'".assertPartialEvaluated(true) }

	@Test def void greaterThanString() { "eval 'ab' > 'a'".assertPartialEvaluated(true) }

	@Test def void greaterEqualsThanString() { "eval 'a' >= 'ab'".assertPartialEvaluated(false) }

	@Test def void equalsString() { "eval 'a' == 'a'".assertPartialEvaluated(true) }

	@Test def void notEqualsString() { "eval 'a' != 'b'".assertPartialEvaluated(true) }

	@Test def void equalsInt() { "eval 1 == 1".assertPartialEvaluated(true) }

	@Test def void notEqualsInt() { "eval 0 != 1".assertPartialEvaluated(true) }

	@Test def void equalsBool() { "eval true == true".assertPartialEvaluated(true) }

	@Test def void notEqualsBool() { "eval true != false".assertPartialEvaluated(true) }

	@Test def void and() { "eval true && !false".assertPartialEvaluated(true) }

	@Test def void or() { "eval false || true".assertPartialEvaluated(true) }

	@Test def void varRef() { "var i = 1 var j = i + 2 eval j+1".assertPartialEvaluated(4) }

	@Test def void varSameVarRef() { "var i = 1 eval i+i".assertPartialEvaluated(2) }

	@Test def void function() { "let inc(int i) => i+1 eval inc(3)".assertPartialEvaluated(4) }

	@Test def void functionWithVar() { "let inc(int i) => i+1 var j = 3*4 eval inc(j)".assertPartialEvaluated(13) }

	@Test def void functionSameParamNameAsVar() { "let inc(int i) => i+1 var i = 42 eval inc(i)".assertPartialEvaluated(43) }

	@Test def void functionComplex() {
		'''
			let isRectangle(int a, int b, int c){ 
				var aLong = a*a == b*b + c*c 
				var bLong = b*b == a*a + c*c 
				var cLong = c*c == b*b + a*a 
				eval aLong||bLong||cLong
			} 
			eval isRectangle(3,4,5)
		'''.assertPartialEvaluated(true)
	}
	
	@Test def void functionRecursive() {
		'''
			let fib(int x){
				var ret = 1
				if x > 2 {
					var ret = fib(x-1) + fib(x-2)
				} 
				eval ret
			}
			eval fib(12)
		'''.assertPartialEvaluated(144)
	}
	
	@Test def void functionComplexInInline() {
		'''
			let add(int x, int add){
				var ret = x
				var x = x + add 
				eval ret
			}
			let inc(int x) => add(:x,1)
			var after = 5
			var before = inc(:after)
			eval after - before
			
		'''.assertPartialEvaluated(1)
	}

	@Test def void functionWithCapture() {
		'''
			let addNminus(int a, int b, int minus) { 
				var minus = a - b 
				eval a + b
			} 
			var sideEffect = 0
			eval addNminus(4,2,:sideEffect)
			eval sideEffect
			
		'''.assertPartialEvaluated(2)
	}

	@Test def void functionWithCaptureRecursive() {
		'''
			let factN(int n, int fact) { 
				if n > 0 {
					eval factN(n-1,:fact)
					var fact = fact * n
				}
				eval fact
			} 
			var sideEffect = 1
			eval factN(5,:sideEffect)
			eval sideEffect
			
		'''.assertPartialEvaluated(
			'''
				let factN(int n, int fact) { 
					if n > 0 {
						eval factN(n-1,:fact)
						var fact = fact * n
					}
					eval fact
				} 
				var sideEffect = 1
				var n = 5
				if n > 0 {
					eval factN(n-1,:sideEffect)
					var sideEffect = sideEffect * n
				}
				eval sideEffect
				eval sideEffect
				
			'''
		)
	}

	@Test def void ifElseStatment() {
		'''
			var a = 0
			if true {
				var a = 144
			} else {
				var a = 1
			}
			
			if false {
				var a = a / 12
			} else {
				var a = a - 102
			}
			eval a
		'''.assertPartialEvaluated(
			'''
			var a = 0
			var a = 14
			var a = a - 102
			eval a
			'''
		)
	}

	@Test def void ifOnlyStatment() {
		'''
			var a = 0
			if true {
				var a = 42
			}
			
			if false {
				var a = a / 12
			}
			eval a
		'''.assertPartialEvaluated(
			'''
			var a = 0
			var a = 42
			eval a
			'''
		)
	}

	@Test def void loopStatment() {
		'''
			var count = 0
			loop count < 6 {
				var count = count + 2
			}
			eval count
		'''.assertPartialEvaluated(
		'''
			var count = 0
			var count = 0 + 2
			var count = 2 + 2
			var count = 4 + 2
			eval count
		''')
	}

	@Test def void complex() { "eval ((5 * 3)+1) / (7 + 1)".assertPartialEvaluated('eval 2') }

	def assertPartialEvaluated(CharSequence input, String expectedCode) {
		val expected = expectedCode.parse
		input.parse => [
			assertNoErrors
			val res = partialEvaluation(newArrayList)
			assertTrue(eq.equals(expected, res))
		]
	}

}
